## SECTION 1. 시간 복잡도란?
- 시간 복잡도(time complexity)는 코드의 실행시간이 어떤 요인으로 결정되는지 나타내는 시간과 입력 데이터의 함수 관계.

### 2.1.1 빅오(Big-O) 표기법
- 알고리즘이 겪을 수 있는 최악의 경우에 걸리는 시간과 입력 간의 상관관계를 표기.
- 입력 크기가 N이고, 이에 비례하는 시간이 걸린다면 O(N)으로 표기.

### 2.1.2 시간 복잡도 그래프
- 입력 크기와 실행 시간의 상관관계
	- 입력크기 작음 -> 연산이 적어 시간 복잡도가 의미있는 차이를 만들지 않음
	- 입력크기 큼 ->  실행 시간의 차이가 크기 때문에 시간 복잡도가 크게 달라짐
	![](https://i.imgur.com/DkgkCk4.png)

| 알고리즘  | 시간 복잡도    |
| ----- | :-------- |
| 이진 탐색 | O(logN)   |
| 선형 탐색 | O(N)      |
| 정렬    | O(N logN) |
| 조합    | O(2ⁿ)     |
| 순열    | O(N!)     |

## SECTION 2. 시간 복잡도 계산하기

### 2.2.1 어림짐작해보기
- ex 1) 길이가 N인 배열의 반만 사용하는 알고리즘
	- 반복 횟수는 N/2 -> O(N/2)
	- 상수 부분을 제외하고 O(N)으로만 표기 (N에 비례함을 나타냄)
- ex 2) 길이가 N인 배열을 두번 반복하는 알고리즘
	- O(2N)이 아닌 O(N)으로 표기
	즉,  O(N) = O(2N) = O(N/2)이 성립함
	
- ex 3) 길이가 N인 배열을 M번 반복하는 알고리즘
	- O(NM)
	- 문제 조건에 따라 N뿐만이 아니라 M의 최댓값 또한 구하여 시간 복잡도에 대입해야함
- ex 4) 길이가 N인 배열을 순회하고 그 다음에 길이가 M인 배열을 순회하는 알고리즘
	- N번 반복 후 M번 반복 -> O(N+M)
	- 이때에도 N과 M의 최댓값을 구하여 시간 복잡도에 대입해 효율성 판단

### 2.2.2 시간 복잡도를 줄이는 방법
- ex 1) 정렬된 배열 arr에서 특정 원소의 위치를 찾는 문제
	- 배열의 모든 원소 순회 -> O(N)
	- 정렬되어있다는 조건을 이용해 이진 탐색 -> O(logN)
- ex 2) 배열에서 중복을 제거한 원소들을 찾는 문제
	- 원소 별로 배열 전체 순회 -> O(N²)
	- 자료구조 Set 이용 -> O(N)

- 문제에서 주어진 입력 조건을 이용해 필요한 알고리즘 유추하기

| N        | 유추 가능한 시간 복잡도    | 유추 가능한 알고리즘  |
| -------- | ---------------- | ------------ |
| 10       | O(N!)            | 순열           |
| 20       | O(2ⁿ)            | 조합           |
| 1,000 ~  | O(N³), O(N³logN) | 완전 탐색, 이진 탐색 |
| 10,000 ~ | O(N logN)        | 정렬 이진탐색      |






